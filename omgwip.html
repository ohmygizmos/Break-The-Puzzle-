<!DOCTYPE html>
<html>
<head>
	<meta http-equiv="content-type" content="text/html; charset=utf-8"/>
	<title></title>
	<meta name="generator" content="LibreOffice 24.8.3.2 (Linux)"/>
	<meta name="created" content="00:00:00"/>
	<meta name="changed" content="00:00:00"/>
	<style type="text/css">
		@page { size: 8.5in 11in; margin: 0.79in }
		p { line-height: 115%; margin-bottom: 0.1in; background: transparent }
		pre { background: transparent }
		pre.western { font-family: "Liberation Mono", monospace; font-size: 10pt }
		pre.cjk { font-family: "Noto Sans Mono CJK SC", monospace; font-size: 10pt }
		pre.ctl { font-family: "Liberation Mono", monospace; font-size: 10pt }
	</style>
</head>
<body lang="en-US" link="#000080" vlink="#800000" dir="ltr"><pre class="western">import pygame
import sys
from pygame import Vector2
import time
import math

# Initialize Pygame
pygame.init()

# Constants
WINDOW_SIZE = 800
BLOCK_SIZE = 50
GRID_SIZE = WINDOW_SIZE // BLOCK_SIZE
FPS = 60
MOVE_DELAY = 150  # Milliseconds between moves

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
PURPLE = (128, 0, 128)
CYAN = (0, 255, 255)
ORANGE = (255, 165, 0)
BROWN = (165, 42, 42)
GRAY = (128, 128, 128)

# Color dictionary for color mechanics
COLORS = {
    &quot;red&quot;: RED,
    &quot;blue&quot;: BLUE,
    &quot;green&quot;: GREEN,
    &quot;yellow&quot;: YELLOW,
    &quot;purple&quot;: PURPLE,
    &quot;orange&quot;: ORANGE
}

class Block:
    def __init__(self, pos, color, block_type=&quot;wall&quot;):
        self.pos = Vector2(pos[0], pos[1])
        self.color = color
        self.block_type = block_type
        self.rect = pygame.Rect(pos[0] * BLOCK_SIZE, pos[1] * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
        self.is_active = True
        self.direction = Vector2(0, 0)  # For moving platforms and rotating blocks
        self.speed = 0.02  # For moving platforms
        self.original_pos = Vector2(pos[0], pos[1])  # For moving platforms
        self.move_range = 5  # For moving platforms
        self.rotation = 0  # For rotating blocks
        self.cooldown = 0  # For teleporters
        self.color_key = None  # For color switches
        self._last_update = pygame.time.get_ticks()  # For teleporter cooldown

    def move(self, direction):
        self.pos += Vector2(direction)
        self.rect.x = self.pos.x * BLOCK_SIZE
        self.rect.y = self.pos.y * BLOCK_SIZE

    def draw(self, screen):
        if self.is_active:
            if self.block_type == &quot;rotating_block&quot;:
                # Draw rotating block with lines showing rotation
                pygame.draw.rect(screen, self.color, self.rect)
                center = self.rect.center
                end_pos = (
                    center[0] + math.cos(self.rotation) * BLOCK_SIZE/2,
                    center[1] + math.sin(self.rotation) * BLOCK_SIZE/2
                )
                pygame.draw.line(screen, BLACK, center, end_pos, 2)
            elif self.block_type == &quot;teleporter&quot;:
                # Draw teleporter with cooldown indicator
                pygame.draw.rect(screen, self.color, self.rect)
                if self.cooldown &gt; 0:
                    cooldown_height = (self.cooldown / 1000) * BLOCK_SIZE
                    cooldown_rect = pygame.Rect(
                        self.rect.x, 
                        self.rect.y + BLOCK_SIZE - cooldown_height,
                        BLOCK_SIZE,
                        cooldown_height
                    )
                    pygame.draw.rect(screen, (100, 100, 100), cooldown_rect)
            else:
                pygame.draw.rect(screen, self.color, self.rect)
            
            pygame.draw.rect(screen, BLACK, self.rect, 1)
            
            if self.block_type == &quot;one_way&quot;:
                # Draw direction arrow
                arrow_points = []
                if self.direction.x == 1:  # Right
                    arrow_points = [(self.rect.left + 10, self.rect.centery - 10),
                                  (self.rect.right - 10, self.rect.centery),
                                  (self.rect.left + 10, self.rect.centery + 10)]
                elif self.direction.x == -1:  # Left
                    arrow_points = [(self.rect.right - 10, self.rect.centery - 10),
                                  (self.rect.left + 10, self.rect.centery),
                                  (self.rect.right - 10, self.rect.centery + 10)]
                elif self.direction.y == 1:  # Down
                    arrow_points = [(self.rect.centerx - 10, self.rect.top + 10),
                                  (self.rect.centerx, self.rect.bottom - 10),
                                  (self.rect.centerx + 10, self.rect.top + 10)]
                elif self.direction.y == -1:  # Up
                    arrow_points = [(self.rect.centerx - 10, self.rect.bottom - 10),
                                  (self.rect.centerx, self.rect.top + 10),
                                  (self.rect.centerx + 10, self.rect.bottom - 10)]
                if arrow_points:
                    pygame.draw.polygon(screen, BLACK, arrow_points)

    def update(self):
        current_time = pygame.time.get_ticks()
        
        if self.block_type == &quot;moving_platform&quot;:
            # Update position based on movement pattern
            offset = pygame.math.Vector2(
                self.original_pos.x + self.direction.x * self.move_range * abs(math.sin(current_time * self.speed)),
                self.original_pos.y + self.direction.y * self.move_range * abs(math.sin(current_time * self.speed))
            )
            self.pos = Vector2(offset.x, offset.y)
            self.rect.x = self.pos.x * BLOCK_SIZE
            self.rect.y = self.pos.y * BLOCK_SIZE
        elif self.block_type == &quot;rotating_block&quot;:
            # Update rotation
            self.rotation = (current_time * self.speed) % (2 * math.pi)
            # Update direction vector based on rotation
            rot_x = math.cos(self.rotation)
            rot_y = math.sin(self.rotation)
            self.direction = Vector2(rot_x, rot_y).normalize()
        elif self.block_type == &quot;teleporter&quot;:
            # Update cooldown
            if self.cooldown &gt; 0:
                self.cooldown = max(0, self.cooldown - (current_time - self._last_update))
                self._last_update = current_time

class Level:
    def __init__(self, level_data):
        self.walls = []
        self.moving_platforms = []
        self.rotating_blocks = []
        self.teleporters = []
        self.portals = []
        self.ice = []
        self.one_way_paths = []
        self.color_switches = []
        self.color_doors = []
        self.buttons = []
        self.doors = []
        self.keys = []
        
        # Add walls
        for wall_pos in level_data.get(&quot;walls&quot;, []):
            if 0 &lt;= wall_pos[0] &lt; GRID_SIZE and 0 &lt;= wall_pos[1] &lt; GRID_SIZE:
                wall = Block(wall_pos, GRAY)
                self.walls.append(wall)
            
        # Add moving platforms
        for platform_data in level_data.get(&quot;moving_platforms&quot;, []):
            pos = platform_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                platform = Block(pos, BLUE, &quot;moving_platform&quot;)
                dir_x, dir_y = platform_data[&quot;direction&quot;]
                platform.direction = Vector2(dir_x, dir_y)
                platform.move_range = platform_data.get(&quot;range&quot;, 3)
                platform.speed = platform_data.get(&quot;speed&quot;, 0.02)
                self.moving_platforms.append(platform)
            
        # Add rotating blocks
        for block_data in level_data.get(&quot;rotating_blocks&quot;, []):
            pos = block_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                block = Block(pos, BROWN, &quot;rotating_block&quot;)
                block.speed = block_data.get(&quot;speed&quot;, 0.001)
                dir_x, dir_y = block_data.get(&quot;direction&quot;, (1, 0))
                block.direction = Vector2(dir_x, dir_y)
                self.rotating_blocks.append(block)
            
        # Add teleporters
        for teleporter_data in level_data.get(&quot;teleporters&quot;, []):
            pos = teleporter_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                teleporter = Block(pos, PURPLE, &quot;teleporter&quot;)
                target_x, target_y = teleporter_data[&quot;target&quot;]
                teleporter.target = Vector2(target_x, target_y)
                self.teleporters.append(teleporter)
            
        # Add portals
        portals = level_data.get(&quot;portals&quot;, [])
        for i in range(0, len(portals), 2):
            if i + 1 &lt; len(portals):
                portal1_pos = portals[i]
                portal2_pos = portals[i + 1]
                if (0 &lt;= portal1_pos[0] &lt; GRID_SIZE and 0 &lt;= portal1_pos[1] &lt; GRID_SIZE and
                    0 &lt;= portal2_pos[0] &lt; GRID_SIZE and 0 &lt;= portal2_pos[1] &lt; GRID_SIZE):
                    portal1 = Block(portal1_pos, CYAN, &quot;portal&quot;)
                    portal2 = Block(portal2_pos, CYAN, &quot;portal&quot;)
                    self.portals.extend([portal1, portal2])
            
        # Add ice blocks
        for ice_pos in level_data.get(&quot;ice&quot;, []):
            if 0 &lt;= ice_pos[0] &lt; GRID_SIZE and 0 &lt;= ice_pos[1] &lt; GRID_SIZE:
                ice = Block(ice_pos, WHITE, &quot;ice&quot;)
                self.ice.append(ice)
            
        # Add one-way paths
        for path_data in level_data.get(&quot;one_way_paths&quot;, []):
            pos = path_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                path = Block(pos, YELLOW, &quot;one_way_path&quot;)
                dir_x, dir_y = path_data[&quot;direction&quot;]
                path.direction = Vector2(dir_x, dir_y)
                self.one_way_paths.append(path)
            
        # Add color switches
        for switch_data in level_data.get(&quot;color_switches&quot;, []):
            pos = switch_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                switch = Block(pos, COLORS[switch_data[&quot;color&quot;]], &quot;color_switch&quot;)
                switch.color_key = switch_data[&quot;color&quot;]
                self.color_switches.append(switch)
            
        # Add color doors
        for door_data in level_data.get(&quot;color_doors&quot;, []):
            pos = door_data[&quot;pos&quot;]
            if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                door = Block(pos, COLORS[door_data[&quot;color&quot;]], &quot;color_door&quot;)
                door.color_key = door_data[&quot;color&quot;]
                self.color_doors.append(door)
            
        # Add buttons and doors
        for i, button_pos in enumerate(level_data.get(&quot;buttons&quot;, [])):
            if 0 &lt;= button_pos[0] &lt; GRID_SIZE and 0 &lt;= button_pos[1] &lt; GRID_SIZE:
                button = Block(button_pos, RED, &quot;button&quot;)
                self.buttons.append(button)
            
        for i, door_pos in enumerate(level_data.get(&quot;doors&quot;, [])):
            if 0 &lt;= door_pos[0] &lt; GRID_SIZE and 0 &lt;= door_pos[1] &lt; GRID_SIZE:
                door = Block(door_pos, ORANGE, &quot;door&quot;)
                self.doors.append(door)
            
        # Add keys
        for key_pos in level_data.get(&quot;keys&quot;, []):
            if 0 &lt;= key_pos[0] &lt; GRID_SIZE and 0 &lt;= key_pos[1] &lt; GRID_SIZE:
                key = Block(key_pos, YELLOW, &quot;key&quot;)
                self.keys.append(key)
            
        # Ensure player and goal positions are valid
        player_pos = level_data[&quot;player&quot;]
        goal_pos = level_data[&quot;goal&quot;]
        if not (0 &lt;= player_pos[0] &lt; GRID_SIZE and 0 &lt;= player_pos[1] &lt; GRID_SIZE):
            player_pos = (1, 1)
        if not (0 &lt;= goal_pos[0] &lt; GRID_SIZE and 0 &lt;= goal_pos[1] &lt; GRID_SIZE):
            goal_pos = (GRID_SIZE-2, GRID_SIZE-2)
        
        self.player = Block(player_pos, RED, &quot;player&quot;)
        self.goal = Block(goal_pos, BLUE, &quot;goal&quot;)
        self.start_time = time.time()
        self.moves = 0
        self.sliding = False
        self.slide_direction = Vector2(0, 0)
        self.active_color = None
        
    def draw(self, screen):
        for ice in self.ice:
            ice.draw(screen)
        for path in self.one_way_paths:
            path.draw(screen)
        for platform in self.moving_platforms:
            platform.draw(screen)
        for wall in self.walls:
            wall.draw(screen)
        for button in self.buttons:
            button.draw(screen)
        for door in self.doors:
            door.draw(screen)
        for key in self.keys:
            key.draw(screen)
        for portal in self.portals:
            portal.draw(screen)
        for block in self.rotating_blocks:
            block.draw(screen)
        for teleporter in self.teleporters:
            teleporter.draw(screen)
        for switch in self.color_switches:
            switch.draw(screen)
        for door in self.color_doors:
            door.draw(screen)
        self.goal.draw(screen)
        self.player.draw(screen)

    def update(self):
        # Update all blocks that need updating
        for block in (self.moving_platforms + self.rotating_blocks + self.teleporters):
            block.update()

    def is_collision(self, pos):
        return any(wall.pos == pos and wall.is_active for wall in self.walls + self.doors + self.moving_platforms)

    def check_button_press(self, pos):
        for i, button in enumerate(self.buttons):
            if button.pos == pos and button.is_active:
                self.doors[i].is_active = not self.doors[i].is_active
                return True
        return False

    def collect_key(self, pos):
        for key in self.keys:
            if key.pos == pos and key.is_active:
                key.is_active = False
                return True
        return False

    def check_portal(self, pos):
        for i in range(0, len(self.portals), 2):
            if self.portals[i].pos == pos:
                return self.portals[i + 1].pos
            elif self.portals[i + 1].pos == pos:
                return self.portals[i].pos
        return None

    def check_one_way_path(self, pos, move_direction):
        for path in self.one_way_paths:
            if path.pos == pos:
                # Only allow movement in the path's direction
                return bool(path.direction.dot(move_direction) &gt; 0)
        return True

    def check_ice(self, pos):
        return any(ice.pos == pos for ice in self.ice)

    def check_rotating_block(self, pos):
        for block in self.rotating_blocks:
            if block.pos == pos:
                # Check if player's movement aligns with block's current direction
                return block.direction
        return None

    def check_teleporter(self, pos):
        for teleporter in self.teleporters:
            if teleporter.pos == pos and teleporter.cooldown &lt;= 0:
                teleporter.cooldown = 1000  # 1 second cooldown
                return teleporter.target
        return None

    def check_color_switch(self, pos):
        for switch in self.color_switches:
            if switch.pos == pos:
                self.active_color = switch.color_key
                # Update color doors
                for door in self.color_doors:
                    door.is_active = (door.color_key != self.active_color)
                return True
        return False

    def move_player(self, direction):
        if self.sliding:
            # Continue sliding in the same direction
            new_pos = self.player.pos + self.slide_direction
            if not self.is_collision(new_pos) and self.check_one_way_path(new_pos, self.slide_direction):
                self.player.pos = new_pos
                self.player.rect.x = self.player.pos.x * BLOCK_SIZE
                self.player.rect.y = self.player.pos.y * BLOCK_SIZE
                if not self.check_ice(new_pos):
                    self.sliding = False
            else:
                self.sliding = False
        else:
            new_pos = self.player.pos + direction
            if not self.is_collision(new_pos) and self.check_one_way_path(new_pos, direction):
                self.moves += 1
                
                # Check all special blocks
                rotating_dir = self.check_rotating_block(new_pos)
                if rotating_dir:
                    direction = rotating_dir
                
                teleport_pos = self.check_teleporter(new_pos)
                if teleport_pos is not None:
                    self.player.pos = teleport_pos
                    self.player.rect.x = self.player.pos.x * BLOCK_SIZE
                    self.player.rect.y = self.player.pos.y * BLOCK_SIZE
                    return
                
                self.check_button_press(new_pos)
                self.collect_key(new_pos)
                self.check_color_switch(new_pos)
                
                portal_pos = self.check_portal(new_pos)
                if portal_pos is not None:
                    self.player.pos = portal_pos
                    self.player.rect.x = self.player.pos.x * BLOCK_SIZE
                    self.player.rect.y = self.player.pos.y * BLOCK_SIZE
                else:
                    self.player.pos = new_pos
                    self.player.rect.x = self.player.pos.x * BLOCK_SIZE
                    self.player.rect.y = self.player.pos.y * BLOCK_SIZE
                
                # Check if landed on ice
                if self.check_ice(new_pos):
                    self.sliding = True
                    self.slide_direction = direction

    def is_complete(self):
        return self.player.pos == self.goal.pos

    def get_score(self):
        time_taken = int(time.time() - self.start_time)
        return max(1000 - (time_taken * 10) - (self.moves * 5), 0)

def get_levels():
    levels = [
        # Level 1: Simple Walls
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)] +
                    [(3, i) for i in range(3, 12)] +
                    [(11, i) for i in range(3, 12)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 2: Moving Platforms
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [
                {&quot;pos&quot;: (4, 4), &quot;direction&quot;: (1, 0), &quot;range&quot;: 3, &quot;speed&quot;: 0.02},
                {&quot;pos&quot;: (10, 10), &quot;direction&quot;: (0, 1), &quot;range&quot;: 3, &quot;speed&quot;: 0.02}
            ],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 3: Buttons and Keys
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)] +
                    [(7, i) for i in range(5, 12)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [(3, 3)],
            &quot;doors&quot;: [(7, 7)],
            &quot;keys&quot;: [(5, 5)]
        },
        # Level 4: Ice Blocks
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [(i, 7) for i in range(3, 12)],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 5: One Way Paths
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [
                {&quot;pos&quot;: (7, i), &quot;direction&quot;: (1, 0)} for i in range(3, 12)
            ],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 6: Color Switches
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)] +
                    [(7, i) for i in range(3, 12)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [
                {&quot;pos&quot;: (3, 3), &quot;color&quot;: &quot;red&quot;},
                {&quot;pos&quot;: (11, 11), &quot;color&quot;: &quot;blue&quot;}
            ],
            &quot;color_doors&quot;: [
                {&quot;pos&quot;: (7, 5), &quot;color&quot;: &quot;red&quot;},
                {&quot;pos&quot;: (7, 9), &quot;color&quot;: &quot;blue&quot;}
            ],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 7: Rotating Blocks
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [
                {&quot;pos&quot;: (7, 7), &quot;speed&quot;: 0.001},
                {&quot;pos&quot;: (7, 8), &quot;speed&quot;: 0.002}
            ],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 8: Teleporters
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)] +
                    [(7, i) for i in range(3, 12)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [
                {&quot;pos&quot;: (3, 3), &quot;target&quot;: (11, 3)},
                {&quot;pos&quot;: (3, 11), &quot;target&quot;: (11, 11)}
            ],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 9: Portals
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)] +
                    [(7, i) for i in range(3, 12)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [(3, 3), (11, 3), (3, 11), (11, 11)],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        },
        # Level 10: Mixed Mechanics
        {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(i, 0) for i in range(GRID_SIZE)] +
                    [(i, GRID_SIZE-1) for i in range(GRID_SIZE)] +
                    [(0, i) for i in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, i) for i in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [
                {&quot;pos&quot;: (7, 7), &quot;direction&quot;: (1, 0), &quot;range&quot;: 3, &quot;speed&quot;: 0.02}
            ],
            &quot;rotating_blocks&quot;: [{&quot;pos&quot;: (3, 3), &quot;speed&quot;: 0.001}],
            &quot;teleporters&quot;: [{&quot;pos&quot;: (11, 11), &quot;target&quot;: (3, 11)}],
            &quot;portals&quot;: [(5, 5), (9, 9)],
            &quot;ice&quot;: [(i, 7) for i in range(4, 6)],
            &quot;one_way_paths&quot;: [{&quot;pos&quot;: (7, 3), &quot;direction&quot;: (1, 0)}],
            &quot;color_switches&quot;: [{&quot;pos&quot;: (2, 2), &quot;color&quot;: &quot;red&quot;}],
            &quot;color_doors&quot;: [{&quot;pos&quot;: (12, 12), &quot;color&quot;: &quot;red&quot;}],
            &quot;buttons&quot;: [(4, 4)],
            &quot;doors&quot;: [(8, 8)],
            &quot;keys&quot;: [(6, 6)]
        }
    ]
    
    # Add remaining levels (11-100) with EXTREME challenge
    for i in range(11, 101):
        level = {
            &quot;player&quot;: (1, 1),
            &quot;goal&quot;: (13, 13),
            &quot;walls&quot;: [(x, 0) for x in range(GRID_SIZE)] +
                    [(x, GRID_SIZE-1) for x in range(GRID_SIZE)] +
                    [(0, y) for y in range(GRID_SIZE)] +
                    [(GRID_SIZE-1, y) for y in range(GRID_SIZE)],
            &quot;moving_platforms&quot;: [],
            &quot;rotating_blocks&quot;: [],
            &quot;teleporters&quot;: [],
            &quot;portals&quot;: [],
            &quot;ice&quot;: [],
            &quot;one_way_paths&quot;: [],
            &quot;color_switches&quot;: [],
            &quot;color_doors&quot;: [],
            &quot;buttons&quot;: [],
            &quot;doors&quot;: [],
            &quot;keys&quot;: []
        }
        
        # Extreme difficulty scaling (0-15)
        difficulty = min(15, (i - 11) // 6)  # Faster scaling
        
        # Add more mechanics at once (up to 8)
        mechanics = [(i + offset) % 8 for offset in range(min(5 + difficulty // 2, 8))]
        
        # Moving Platforms - EXTREME speed and complexity
        if 0 in mechanics:
            platform_count = min(4 + difficulty // 2, 8)  # More platforms
            for p in range(platform_count):
                speed = 0.08 + (difficulty * 0.015)  # MUCH faster
                range_val = 4 + difficulty
                pos = (0, 0)
                direction = (0, 0)
                
                if p % 4 == 0:
                    pos = (4 + (p % 2) * 6, 4)
                    direction = (1, 1) if p % 2 == 0 else (-1, 1)
                elif p % 4 == 1:
                    pos = (4, 4 + (p % 2) * 6)
                    direction = (1, -1) if p % 2 == 0 else (1, 1)
                elif p % 4 == 2:
                    pos = (10 - (p % 2) * 6, 10)
                    direction = (-1, -1) if p % 2 == 0 else (1, -1)
                else:
                    pos = (7, 7 + (p % 2) * 4)
                    direction = (-1, 1) if p % 2 == 0 else (1, 1)
                
                if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                    level[&quot;moving_platforms&quot;].append({
                        &quot;pos&quot;: pos,
                        &quot;direction&quot;: direction,
                        &quot;range&quot;: range_val,
                        &quot;speed&quot;: speed * (1.5 if abs(direction[0] + direction[1]) &gt; 1 else 1)  # Even faster diagonals
                    })
        
        # Rotating Blocks - EXTREME rotation speed
        if 1 in mechanics:
            positions = [(7, 7), (4, 4), (10, 10), (4, 10), (10, 4), (7, 4), (4, 7), (10, 7)]
            block_count = min(3 + difficulty // 2, len(positions))
            base_speed = 0.006 * (1.6 ** difficulty)  # Much faster base rotation
            
            for b in range(block_count):
                pos = positions[b]
                if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                    level[&quot;rotating_blocks&quot;].append({
                        &quot;pos&quot;: pos,
                        &quot;speed&quot;: base_speed * (1.4 ** b)  # Faster speed increase per block
                    })
        
        # Teleporters - Complex network with chain reactions
        if 2 in mechanics:
            positions = [(3, 3), (11, 11), (3, 11), (11, 3), (7, 3), (7, 11), (3, 7), (11, 7),
                        (5, 5), (9, 9), (5, 9), (9, 5)]  # More teleporter positions
            teleporter_count = min(6 + difficulty // 2, len(positions))
            teleporter_count = teleporter_count - (teleporter_count % 2)
            
            for t in range(0, teleporter_count, 2):
                if t + 1 &lt; teleporter_count:
                    pos1, pos2 = positions[t], positions[t + 1]
                    if (0 &lt;= pos1[0] &lt; GRID_SIZE and 0 &lt;= pos1[1] &lt; GRID_SIZE and
                        0 &lt;= pos2[0] &lt; GRID_SIZE and 0 &lt;= pos2[1] &lt; GRID_SIZE):
                        # Create chain teleportation
                        next_t = (t + 2) % teleporter_count
                        next_pos = positions[next_t]
                        level[&quot;teleporters&quot;].extend([
                            {&quot;pos&quot;: pos1, &quot;target&quot;: pos2},
                            {&quot;pos&quot;: pos2, &quot;target&quot;: next_pos}
                        ])
        
        # Portals - Complex portal maze
        if 3 in mechanics:
            positions = [(3, 3), (11, 3), (3, 11), (11, 11), (7, 3), (7, 11), (3, 7), (11, 7),
                        (5, 5), (9, 9), (5, 9), (9, 5)]  # More portal positions
            portal_count = min(4 + difficulty // 2, len(positions))
            portal_count = portal_count - (portal_count % 2)
            
            for p in range(0, portal_count, 2):
                if p + 1 &lt; len(positions):
                    pos = positions[p]
                    if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                        level[&quot;portals&quot;].append(pos)
        
        # Ice - EXTREME ice patterns
        if 4 in mechanics:
            ice_positions = []
            if difficulty &gt; 8:
                # Spiral maze pattern
                for d in range(1, min(6, GRID_SIZE // 2)):
                    for x in range(3+d, 12-d):
                        if 0 &lt;= x &lt; GRID_SIZE and 0 &lt;= 3+d &lt; GRID_SIZE:
                            ice_positions.append((x, 3+d))
                        if 0 &lt;= x &lt; GRID_SIZE and 0 &lt;= 11-d &lt; GRID_SIZE:
                            ice_positions.append((x, 11-d))
                    for y in range(4+d, 11-d):
                        if 0 &lt;= 3+d &lt; GRID_SIZE and 0 &lt;= y &lt; GRID_SIZE:
                            ice_positions.append((3+d, y))
                        if 0 &lt;= 11-d &lt; GRID_SIZE and 0 &lt;= y &lt; GRID_SIZE:
                            ice_positions.append((11-d, y))
            elif difficulty &gt; 4:
                # Complex cross with diagonals
                for x in range(3, 12):
                    if x &lt; GRID_SIZE:
                        # Main cross
                        ice_positions.append((x, 7))
                        ice_positions.append((7, x))
                        # Diagonals
                        if x &lt; GRID_SIZE and x &lt; GRID_SIZE:
                            ice_positions.append((x, x))
                        if x &lt; GRID_SIZE and (14-x) &lt; GRID_SIZE:
                            ice_positions.append((x, 14-x))
                        # Extra diagonals
                        if x-2 &lt; GRID_SIZE and x+2 &lt; GRID_SIZE:
                            ice_positions.append((x-2, x+2))
                        if x+2 &lt; GRID_SIZE and x-2 &lt; GRID_SIZE:
                            ice_positions.append((x+2, x-2))
            else:
                # Double cross pattern
                for x in range(3, 12):
                    if x &lt; GRID_SIZE:
                        ice_positions.append((x, 5))
                        ice_positions.append((x, 9))
                        ice_positions.append((5, x))
                        ice_positions.append((9, x))
            
            level[&quot;ice&quot;] = list(set(ice_positions))  # Remove duplicates
        
        # One-way Paths - Complex maze with forced routes
        if 5 in mechanics:
            positions = [(7, 3), (7, 7), (7, 11), (3, 7), (11, 7), (5, 5), (9, 9), (5, 9),
                        (4, 4), (10, 10), (4, 10), (10, 4)]  # More positions
            # Always use diagonal directions for maximum difficulty
            directions = [(1, 1), (-1, 1), (1, -1), (-1, -1)]
            path_count = min(6 + difficulty // 2, len(positions))
            
            for p in range(path_count):
                pos = positions[p]
                if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                    level[&quot;one_way_paths&quot;].append({
                        &quot;pos&quot;: pos,
                        &quot;direction&quot;: directions[p % len(directions)]
                    })
        
        # Color Mechanics - Complex color chains
        if 6 in mechanics:
            colors = [&quot;red&quot;, &quot;blue&quot;, &quot;green&quot;, &quot;yellow&quot;, &quot;purple&quot;, &quot;orange&quot;][:min(4 + difficulty // 3, 6)]
            
            switch_positions = [(3, 3), (11, 3), (3, 11), (11, 11), (7, 3), (7, 11),
                              (5, 5), (9, 9), (5, 9), (9, 5)]  # More switches
            door_positions = [(7, 5), (7, 7), (7, 9), (5, 7), (9, 7), (7, 11),
                            (6, 6), (8, 8), (6, 8), (8, 6)]  # More doors
            
            for c_idx, color in enumerate(colors):
                # Multiple switches per color
                switch_count = min(2 + difficulty // 4, len(switch_positions))
                for s in range(switch_count):
                    pos_idx = (c_idx + s) % len(switch_positions)
                    pos = switch_positions[pos_idx]
                    if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                        level[&quot;color_switches&quot;].append({
                            &quot;pos&quot;: pos,
                            &quot;color&quot;: color
                        })
                
                # Multiple doors per color
                door_count = min(2 + difficulty // 3, len(door_positions))
                for d in range(door_count):
                    pos_idx = (c_idx + d) % len(door_positions)
                    pos = door_positions[pos_idx]
                    if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                        level[&quot;color_doors&quot;].append({
                            &quot;pos&quot;: pos,
                            &quot;color&quot;: color
                        })
        
        # Buttons and Doors - Complex sequences with multiple dependencies
        if 7 in mechanics:
            button_positions = [(3, 3), (11, 3), (3, 11), (11, 11), (7, 3), (7, 11),
                              (5, 5), (9, 9), (5, 9), (9, 5)]  # More buttons
            door_positions = [(7, 5), (7, 7), (7, 9), (5, 7), (9, 7), (7, 11),
                            (6, 6), (8, 8), (6, 8), (8, 6)]  # More doors
            button_count = min(4 + difficulty // 2, len(button_positions))
            
            for b in range(button_count):
                button_pos = button_positions[b]
                if 0 &lt;= button_pos[0] &lt; GRID_SIZE and 0 &lt;= button_pos[1] &lt; GRID_SIZE:
                    level[&quot;buttons&quot;].append(button_pos)
                    # Multiple doors per button
                    door_count = min(2 + difficulty // 3, len(door_positions))
                    for d in range(door_count):
                        pos_idx = (b + d) % len(door_positions)
                        door_pos = door_positions[pos_idx]
                        if 0 &lt;= door_pos[0] &lt; GRID_SIZE and 0 &lt;= door_pos[1] &lt; GRID_SIZE:
                            level[&quot;doors&quot;].append(door_pos)
        
        # Wall Patterns - EXTREME maze patterns
        wall_positions = []
        if difficulty &gt;= 2:
            # Dense vertical walls
            gap_size = max(2, 3 - difficulty // 4)  # Smaller gaps
            for y in range(3, 12):
                if y % gap_size != 0 and y &lt; GRID_SIZE:
                    wall_positions.append((7, y))
                    if difficulty &gt; 6:  # Double walls
                        if 5 &lt; GRID_SIZE:
                            wall_positions.append((5, y))
                        if 9 &lt; GRID_SIZE:
                            wall_positions.append((9, y))
        
        if difficulty &gt;= 4:
            # Dense horizontal walls
            for x in range(3, 12):
                if x % gap_size != 0 and x &lt; GRID_SIZE:
                    wall_positions.append((x, 7))
                    if difficulty &gt; 6:  # Double walls
                        if 5 &lt; GRID_SIZE:
                            wall_positions.append((x, 5))
                        if 9 &lt; GRID_SIZE:
                            wall_positions.append((x, 9))
        
        if difficulty &gt;= 6:
            # Complex diagonal barriers
            for x in range(4, 11):
                if x % (gap_size-1) != 0:  # Even smaller gaps for diagonals
                    if x &lt; GRID_SIZE and x &lt; GRID_SIZE:
                        wall_positions.append((x, x))
                        if difficulty &gt; 8:  # Parallel diagonals
                            if x-1 &lt; GRID_SIZE and x-1 &lt; GRID_SIZE:
                                wall_positions.append((x-1, x-1))
                    if x &lt; GRID_SIZE and (14-x) &lt; GRID_SIZE:
                        wall_positions.append((x, 14-x))
                        if difficulty &gt; 8:  # Parallel diagonals
                            if x-1 &lt; GRID_SIZE and (15-x) &lt; GRID_SIZE:
                                wall_positions.append((x-1, 15-x))
        
        level[&quot;walls&quot;].extend(list(set(wall_positions)))  # Remove duplicates
        
        # Keys - Many required keys in strategic positions
        if difficulty &gt;= 2 or i % 3 == 0:  # Even more frequent keys
            positions = [(5, 5), (9, 9), (5, 9), (9, 5), (7, 4), (7, 10), (4, 7), (10, 7)]
            key_count = min(3 + difficulty // 2, len(positions))  # More keys required
            
            for k in range(key_count):
                pos = positions[k]
                if 0 &lt;= pos[0] &lt; GRID_SIZE and 0 &lt;= pos[1] &lt; GRID_SIZE:
                    level[&quot;keys&quot;].append(pos)
        
        # Ensure player and goal positions are valid
        if not (0 &lt;= level[&quot;player&quot;][0] &lt; GRID_SIZE and 0 &lt;= level[&quot;player&quot;][1] &lt; GRID_SIZE):
            level[&quot;player&quot;] = (1, 1)
        if not (0 &lt;= level[&quot;goal&quot;][0] &lt; GRID_SIZE and 0 &lt;= level[&quot;goal&quot;][1] &lt; GRID_SIZE):
            level[&quot;goal&quot;] = (GRID_SIZE-2, GRID_SIZE-2)
        
        levels.append(level)
    
    return levels

def main():
    screen = pygame.display.set_mode((WINDOW_SIZE, WINDOW_SIZE))
    pygame.display.set_caption(&quot;Break The Puzzle!&quot;)
    clock = pygame.time.Clock()
    
    # Get levels and initialize first level
    levels = get_levels()
    if not levels:
        print(&quot;Error: No levels found!&quot;)
        pygame.quit()
        sys.exit()
        
    current_level = 0
    level = Level(levels[current_level])
    total_score = 0
    font = pygame.font.Font(None, 36)
    last_move_time = 0
    
    while True:
        current_time = pygame.time.get_ticks()
        
        for event in pygame.event.get():
            if event.type == pygame.QUIT:
                pygame.quit()
                sys.exit()
            
            if event.type == pygame.KEYDOWN:
                if event.key == pygame.K_ESCAPE:
                    pygame.quit()
                    sys.exit()
                elif event.key == pygame.K_r:
                    level = Level(levels[current_level])
        
        # Handle continuous key presses with delay
        if current_time - last_move_time &gt;= MOVE_DELAY:
            keys = pygame.key.get_pressed()
            moved = False
            
            if keys[pygame.K_LEFT]:
                level.move_player(Vector2(-1, 0))
                moved = True
            elif keys[pygame.K_RIGHT]:
                level.move_player(Vector2(1, 0))
                moved = True
            elif keys[pygame.K_UP]:
                level.move_player(Vector2(0, -1))
                moved = True
            elif keys[pygame.K_DOWN]:
                level.move_player(Vector2(0, 1))
                moved = True
                
            if moved:
                last_move_time = current_time
        
        # Update moving platforms and other elements
        level.update()
        
        # Draw everything
        screen.fill(WHITE)
        level.draw(screen)
        
        # Draw HUD
        score_text = font.render(f'Score: {level.get_score()}', True, BLACK)
        level_text = font.render(f'Level: {current_level + 1}/{len(levels)}', True, BLACK)
        moves_text = font.render(f'Moves: {level.moves}', True, BLACK)
        screen.blit(score_text, (10, 10))
        screen.blit(level_text, (10, 50))
        screen.blit(moves_text, (10, 90))
        
        # Check win condition
        if level.is_complete():
            total_score += level.get_score()
            current_level += 1
            
            if current_level &gt;= len(levels):
                # Game complete
                complete_text = font.render('Game Complete!', True, BLACK)
                final_score_text = font.render(f'Final Score: {total_score}', True, BLACK)
                screen.blit(complete_text, (WINDOW_SIZE/2 - 100, WINDOW_SIZE/2 - 50))
                screen.blit(final_score_text, (WINDOW_SIZE/2 - 100, WINDOW_SIZE/2 + 50))
            else:
                # Next level
                level = Level(levels[current_level])
        
        pygame.display.flip()
        clock.tick(FPS)

if __name__ == &quot;__main__&quot;:
    main()</pre>
</body>
</html>