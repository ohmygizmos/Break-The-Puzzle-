<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>omgwip.py Code</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            background-color: #f4f4f4;
            padding: 20px;
        }
        pre {
            background-color: #333;
            color: #f8f8f2;
            padding: 10px;
            border-radius: 5px;
            overflow: auto;
        }
    </style>
</head>
<body>
    <h1>omgwip.py Code</h1>
    <pre><code>import pygame
import sys
from pygame import Vector2
import time
import math

# Initialize Pygame
pygame.init()

# Constants
WINDOW_SIZE = 800
BLOCK_SIZE = 50
GRID_SIZE = WINDOW_SIZE // BLOCK_SIZE
FPS = 60
MOVE_DELAY = 150  # Milliseconds between moves

# Colors
WHITE = (255, 255, 255)
BLACK = (0, 0, 0)
RED = (255, 0, 0)
BLUE = (0, 0, 255)
GREEN = (0, 255, 0)
YELLOW = (255, 255, 0)
PURPLE = (128, 0, 128)
CYAN = (0, 255, 255)
ORANGE = (255, 165, 0)
BROWN = (165, 42, 42)
GRAY = (128, 128, 128)

# Color dictionary for color mechanics
COLORS = {
    "red": RED,
    "blue": BLUE,
    "green": GREEN,
    "yellow": YELLOW,
    "purple": PURPLE,
    "orange": ORANGE
}

class Block:
    def __init__(self, pos, color, block_type="wall"):
        self.pos = Vector2(pos[0], pos[1])
        self.color = color
        self.block_type = block_type
        self.rect = pygame.Rect(pos[0] * BLOCK_SIZE, pos[1] * BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE)
        self.is_active = True
        self.direction = Vector2(0, 0)  # For moving platforms and rotating blocks
        self.speed = 0.02  # For moving platforms
        self.original_pos = Vector2(pos[0], pos[1])  # For moving platforms
        self.move_range = 5  # For moving platforms
        self.rotation = 0  # For rotating blocks
        self.cooldown = 0  # For teleporters
        self.color_key = None  # For color switches
        self._last_update = pygame.time.get_ticks()  # For teleporter cooldown

    def move(self, direction):
        self.pos += Vector2(direction)
        self.rect.x = self.pos.x * BLOCK_SIZE
        self.rect.y = self.pos.y * BLOCK_SIZE

    def draw(self, screen):
        if self.is_active:
            if self.block_type == "rotating_block":
                # Draw rotating block with lines showing rotation
                pygame.draw.rect(screen, self.color, self.rect)
                center = self.rect.center
                end_pos = (
                    center[0] + math.cos(self.rotation) * BLOCK_SIZE/2,
                    center[1] + math.sin(self.rotation) * BLOCK_SIZE/2
                )
                pygame.draw.line(screen, BLACK, center, end_pos, 2)
            elif self.block_type == "teleporter":
                # Draw teleporter with cooldown indicator
                pygame.draw.rect(screen, self.color, self.rect)
                if self.cooldown > 0:
                    cooldown_height = (self.cooldown / 1000) * BLOCK_SIZE
                    cooldown_rect = pygame.Rect(
                        self.rect.x, 
                        self.rect.y + BLOCK_SIZE - cooldown_height,
                        BLOCK_SIZE,
                        cooldown_height
                    )
                    pygame.draw.rect(screen, (100, 100, 100), cooldown_rect)
            else:
                pygame.draw.rect(screen, self.color, self.rect)
            
            pygame.draw.rect(screen, BLACK, self.rect, 1)
            
            if self.block_type == "one_way":
                # Draw direction arrow
                arrow_points = []
                if self.direction.x == 1:  # Right
                    arrow_points = [(self.rect.left + 10, self.rect.centery - 10),
                                  (self.rect.right - 10, self.rect.centery),
                                  (self.rect.left + 10, self.rect.centery + 10)]
                elif self.direction.x == -1:  # Left
                    arrow_points = [(self.rect.right - 10, self.rect.centery - 10),
                                  (self.rect.left + 10, self.rect.centery),
                                  (self.rect.right - 10, self.rect.centery + 10)]
                elif self.direction.y == 1:  # Down
                    arrow_points = [(self.rect.centerx - 10, self.rect.top + 10),
                                  (self.rect.centerx, self.rect.bottom - 10),
                                  (self.rect.centerx + 10, self.rect.top + 10)]
                elif self.direction.y == -1:  # Up
                    arrow_points = [(self.rect.centerx - 10, self.rect.bottom - 10),
                                  (self.rect.centerx, self.rect.top + 10),
                                  (self.rect.centerx + 10, self.rect.bottom - 10)]
                if arrow_points:
                    pygame.draw.polygon(screen, BLACK, arrow_points)

    def update(self):
        current_time = pygame.time.get_ticks()
        
        if self.block_type == "moving_platform":
            # Update position based on movement pattern
            offset = pygame.math.Vector2(
                self.original_pos.x + self.direction.x * self.move_range * abs(math.sin(current_time * self.speed)),
                self.original_pos.y + self.direction.y * self.move_range * abs(math.sin(current_time * self.speed))
            )
            self.pos = Vector2(offset.x, offset.y)
            self.rect.x = self.pos.x * BLOCK_SIZE
            self.rect.y = self.pos.y * BLOCK_SIZE
        elif self.block_type == "rotating_block":
            # Update rotation
            self.rotation = (current_time * self.speed) % (2 * math.pi)
            # Update direction vector based on rotation
            rot_x = math.cos(self.rotation)
            rot_y = math.sin(self.rotation)
            self.direction = Vector2(rot_x, rot_y).normalize()
        elif self.block_type == "teleporter":
            # Update cooldown
            if self.cooldown > 0:
                self.cooldown = max(0, self.cooldown - (current_time - self._last_update))
                self._last_update = current_time

class Level:
    def __init__(self, level_data):
        self.walls = []
        self.moving_platforms = []
        self.rotating_blocks = []
        self.teleporters = []
        self.portals = []
        self.ice = []
        self.one_way_paths = []
        self.color_switches = []
        self.color_doors = []
        self.buttons = []
        self.doors = []
        self.keys = []
        
        # Add walls
        for wall_pos in level_data.get("walls", []):
            if 0 <= wall_pos[0] < GRID_SIZE and 0 <= wall_pos[1] < GRID_SIZE:
                wall = Block(wall_pos, GRAY)
                self.walls.append(wall)
            
        # Add moving platforms
        for platform_data in level_data.get("moving_platforms", []):
            pos = platform_data["pos"]
            if 0 <= pos[0] < GRID_SIZE and 0 <= pos[1] < GRID_SIZE:
                platform = Block(pos, BLUE, "moving_platform")
                dir_x, dir_y = platform_data["direction"]
                platform.direction = Vector2(dir_x, dir_y)
                platform.move_range = platform_data.get("range", 3)
                platform.speed = platform_data.get("speed", 0.02)
                self.moving_platforms.append(platform)
            
        # Add rotating blocks
        for block_data in level_data.get("rotating_blocks", []):
            pos = block_data["pos"]
            if 0 <= pos[0] < GRID_SIZE and 0 <= pos[1] < GRID_SIZE:
                block = Block(pos, BROWN, "rotating_block")
                block.speed = block_data.get("speed", 0.001)
                dir_x, dir_y = block_data.get("direction", (1, 0))
                block.direction = Vector2(dir_x, dir_y)
                self.rotating_blocks.append(block)
            
        # Add teleporters
        for teleporter_data in level_data.get("teleporters", []):
            pos = teleporter_data["pos"]
            if 0 <= pos[0] < GRID_SIZE and 0 <= pos[1] < GRID_SIZE:
                teleporter = Block(pos, PURPLE, "teleporter")
                target_x, target_y = teleporter_data["target"]
                teleporter.target = Vector2(target_x, target_y)
                self.teleporters.append(teleporter)
            
        # Add portals
        portals = level_data.get("portals", [])
        for i in range(0, len(portals), 2):
            if i + 1 < len(portals):
                portal1_pos = portals[i]
                portal2_pos = portals[i + 1]
                if (0 <= portal1_pos[0] < GRID_SIZE and 0 <= portal1_pos[1] < GRID_SIZE and
                    0 <= portal2_pos[0] < GRID_SIZE and 0 <= portal2_pos[1] < GRID_SIZE):
                    portal1 = Block(portal1_pos, CYAN, "portal")
                    portal2 = Block(portal2_pos, CYAN, "portal")
                    self.portals.extend([portal1, portal2])
            
        # Add ice blocks
        for ice_pos in level_data.get("ice", []):
            if 0 <= ice_pos[0] < GRID_SIZE and 0 <= ice_pos[1] < GRID_SIZE:
